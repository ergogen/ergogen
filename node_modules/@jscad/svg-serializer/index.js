// import { CSG } from '@jscad/csg'
const {CSG} = require('@jscad/csg')

const mimeType = 'image/svg+xml'

function serialize (cagObject) {
  var decimals = 1000

  // mirror the CAG about the X axis in order to generate paths into the POSITIVE direction
  var plane = new CSG.Plane(CSG.Vector3D.Create(0, 1, 0), 0)
  var cag = cagObject.transform(CSG.Matrix4x4.mirroring(plane))

  var bounds = cag.getBounds()
  var paths = cag.getOutlinePaths()
  var width = Math.round((bounds[1].x - bounds[0].x) * decimals) / decimals
  var height = Math.round((bounds[1].y - bounds[0].y) * decimals) / decimals
  var svg = '<?xml version="1.0" encoding="UTF-8"?>\n'
  svg += '<!-- Generated by OpenJSCAD.org -->\n'
  svg += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">\n'
  svg += '<svg width="' + width + 'mm" height="' + height + 'mm" viewBox="0 0 ' + width + ' ' + height + '" version="1.1" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n'
  svg += PathsToSvg(paths, bounds)
  svg += '</svg>'
  return [svg]
}

function PathsToSvg (paths, bounds) {
  // calculate offsets in order to create paths orientated from the 0,0 axis
  var xoffset = 0 - bounds[0].x
  var yoffset = 0 - bounds[0].y
  var str = '<g>\n'
  paths.map(function (path) {
    str += '<path d="'
    // FIXME add fill color when CAG has support for colors
    var numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    for (var pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      var pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      var point = path.points[pointindexwrapped]
      if (pointindex > 0) {
        str += 'L' + (point.x + xoffset) + ' ' + (point.y + yoffset)
      } else {
        str += 'M' + (point.x + xoffset) + ' ' + (point.y + yoffset)
      }
    }
    str += '"/>\n'
  })
  str += '</g>\n'
  return str
}

module.exports = {
  serialize,
  mimeType
}
